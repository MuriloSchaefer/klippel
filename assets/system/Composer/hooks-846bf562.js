import{b as T,_ as A,r as D}from"../../vendor-14321f5b.js";import{n as m}from"../../kernel-a8fe20a8.js";import{a as $,b as x,c as j,d as V,u as L,e as _,s as k,f as U,g as B,h as q,i as H,j as F,l as Y,k as z,o as J}from"../Composer-6f3a7da5.js";const Z=(g,l)=>{const f=m("Store"),h=m("Layout"),M=m("Graph"),I=m("Materials"),{useAppDispatch:y,useAppSelector:p}=f.hooks,d=y();h.hooks.usePanelsManager();const{useGraph:b}=M.hooks,{useMaterialTypes:v}=I.hooks,u=e=>{if(!e)return;const{compositionName:o,viewportName:t}=g;if(o)return e.Composer.compositionsManager.compositions[o];if(t)return Object.values(e.Composer.compositionsManager.compositions).find(a=>a.viewportName===t);console.warn("either compositionName or viewportName shall be provided")},E=T(u,l),r=p(E),n=p(u),s=b(n?.graphId,e=>({adjacencyList:e?.adjacencyList,nodes:e?.nodes,edges:e?.edges})),R=v();return{state:r,actions:{changeProperties(e,o){const t=s.state?.nodes?.garment;if(!t)throw Error("root node not found");const a={...t,label:e,description:o};s.actions.updateNode(a)},addToBudget(e,o){const t=Object.values(s.state?.nodes??{}).filter(a=>a.type==="GRADE").map(a=>a.id);d($({compositionName:e,budgetId:o,gradesInfo:t}))},addGrade(e,o){const t=A.uniqueId(`${e}-grade-`),a={type:"GRADE",id:t,abbreviation:e,position:{x:0,y:0}};s.actions.addNode(a);const i={type:"HAS_GRADE",id:`garment -> ${t}`,sourceId:"garment",targetId:t,order:o};s.actions.addEdge(i),d(x({compositionName:n?.name,budgetId:n?.budget?.budgetId,gradeId:t}))},reorderGrade(e,o){s.actions.updateEdge(`garment -> ${e}`,{order:o}),Object.values(s.state?.edges??{}).filter(t=>t.type==="HAS_GRADE"&&t.order>=o).sort((t,a)=>t.order-a.order).forEach(t=>s.actions.updateEdge(t.id,{order:t.order+1}))},removeGrade(e){if(!s.state?.edges||!s.state.adjacencyList)throw Error("edges not defined");const t=s.state.adjacencyList[e].inputs.at(0);if(!t)throw Error("edges not found");const{order:a}=s.state.edges[t];s.actions.removeNode(e),Object.values(s.state?.edges??{}).filter(i=>i.type==="HAS_GRADE"&&i.order>a).sort((i,c)=>i.order-c.order).forEach(i=>s.actions.updateEdge(i.id,{order:i.order-1}))},changeGradeCounter(e,o){d(j({compositionName:n?.name,gradeId:e,counter:o}))},addPart(e,o,t){const a={type:"PART",id:e,label:e,position:{x:0,y:0},domId:o};let i;if(t){const c=`${t}->${e}`;i={inputs:{[c]:{id:c,sourceId:t,targetId:e,type:"COMPOSED_OF"}},outputs:{}}}s.actions.addNode(a,i)},removePart(e){s.actions.removeNode(e)},addMaterialUsage(e,o,t){t.forEach(S=>{Object.values(s.state?.nodes??{}).find(O=>O.id===S)||(console.log("adding type node"),s.actions.addNode({id:S,type:"MATERIAL_TYPE",label:R[S].label}))});const a=A.uniqueId("material-usage-"),i={type:"MATERIAL_USAGE",id:a,label:e,editableAttributes:["materialType","materialId"],materialId:"material-12",materialType:t[0]??"malha",position:{x:0,y:0},proxies:[]},c=`${a}-restriction-1`,N=`${o}->${a}`,C={inputs:{[N]:{id:N,sourceId:o,targetId:a,type:"MADE_OF"}},outputs:{}};s.actions.addNode(i,C);const w={type:"RESTRICTION",restrictionType:"allowOnly",attribute:"materialType",id:c,label:"Permitido apenas",operand:t,position:{x:0,y:0}},G=`${a}->${c}`,P={inputs:{[G]:{id:G,sourceId:a,targetId:c,attr:"materialType",type:"RESTRICTED_BY"}},outputs:{}};s.actions.addNode(w,P)},removeMaterialUsage(e){s.actions.removeNode(e)},addRestriction(e,o){d(V({compositionName:n.name,materialId:e,restriction:o}))},updateRestriction(e,o,t){d(L({compositionName:n.name,materialId:e,restrictionId:o,changes:t}))},removeRestriction(e,o){d(_({compositionName:n.name,materialId:e,restrictionId:o}))},removeOperation(e){s.actions.removeNode(e)},addOperation(e,o,t,a){const i=A.uniqueId("operation-"),c=`${a}->${i}`,N={id:i,type:"OPERATION",label:e,position:{x:0,y:0},cost:o,time_taken:t},C={inputs:{[c]:{id:c,sourceId:a,targetId:i,type:"PROCESS_NEEDED"}},outputs:{}};s.actions.addNode(N,C)},updateMaterialConsuption:(e,o)=>{s.actions.updateEdge(e,o)},deleteMaterialConsuption:e=>{s.actions.removeEdge(e)},addMaterialConsuption:(e,o,t)=>{const a={id:`${e}->${o}`,sourceId:e,targetId:o,type:"CONSUMES",quantity:t};s.actions.addEdge(a)},selectPart(e){d(k({compositionName:n.name,partName:e}))},changeMaterialType(e,o){s.actions.nodeExists(o)||d(U({compositionName:n?.name,materialType:o})),s.actions.updateNode({id:e,materialType:o})},changeMaterial(e,o){d(B({compositionName:n?.name,materialUsageId:e,materialId:o}))},addProxy(e,o){d(q({compositionName:n.name,materialId:o,proxy:e}))},deleteProxy(e,o){d(H({compositionName:n.name,materialId:o,proxyId:e}))},updateProxy(){}}}},K=()=>{const g=m("Store"),l=m("Graph"),f=m("Layout"),h=m("SVG"),{useAppDispatch:M,useAppSelector:I}=g.hooks,y=M(),p=f.hooks.useViewportManager(),d=h.hooks.useSVGManager(),b=l.managers.graphs(),{compositionsManager:v}=I(F);return{functions:{listCompositions(){y(Y())},createComposition(u,E){const r=p.functions.addViewport(u,"Composer",void 0,"composition-");p.functions.selectViewport(r);const n=E;b.functions.createGraph(r),y(z({name:r,viewportName:r,svgPath:n,graphId:r})),d.functions.loadSVG(n,r)},createDebugView(u,E){const r=`debug-${u}`;p.functions.createGroup(r,"blue"),p.functions.addToGroup(E,r);const n=p.functions.addViewport("Modelo","DebuggerViewport",r,"debug-");y(J({compositionName:u,debugViewport:n})),p.functions.selectViewport(n)},findComposition(u){return Object.values(v.compositions).find(u)}}}},ee=()=>{const g=m("Store"),{useAppSelector:l}=g.hooks,f=K(),h=l(M=>M.Composer.compositionsManager.compositionsList);return D.useLayoutEffect(()=>{f.functions.listCompositions()},[]),h};export{K as a,ee as b,Z as u};
